---
exclude: true
aside: false
pageClass: diff-single-page
footer: false
editLink: false
lastUpdated: false
description: 0 file modified. 3 files removed.
version: +EA 23.176 Nightly Patch 1 - Plugin.BaseCore
changes: -SpriteData/-SpriteReplacer/-SpriteReplacerAnimation
---

# +EA 23.176 Nightly Patch 1 - Plugin.BaseCore

August 7, 2025

0 file modified. 3 files removed.

## Important Changes

**None.**
## -SpriteData

::: details File Removed
```cs
using System;
using System.Globalization;
using System.IO;
using System.Text;
using IniParser;
using IniParser.Model;
using UnityEngine;

public class SpriteData
{
	public DateTime date;

	public Texture2D tex;

	public Texture2D texSnow;

	public string path;

	public Sprite[] sprites;

	public Sprite[] spritesSnow;

	public int frame = 1;

	public int scale = 50;

	public float time = 0.2f;

	public void Init()
	{
		try
		{
			if (File.Exists(path + ".ini"))
			{
				IniData iniData = new FileIniDataParser().ReadFile(path + ".ini", Encoding.UTF8);
				frame = int.Parse(iniData.GetKey("frame") ?? "1");
				scale = int.Parse(iniData.GetKey("scale") ?? "50");
				time = float.Parse(iniData.GetKey("time") ?? "0.2", CultureInfo.InvariantCulture);
			}
		}
		catch (Exception message)
		{
			Debug.Log(message);
			Debug.Log("exception: Failed to parse:" + path + ".ini");
			time = 0.2f;
			scale = 50;
		}
	}

	public Sprite[] GetSprites()
	{
		Validate();
		return sprites;
	}

	public Sprite GetSprite(bool snow = false)
	{
		Validate();
		if (!snow || spritesSnow == null)
		{
			return sprites[0];
		}
		return spritesSnow[0];
	}

	public void Validate()
	{
		DateTime lastWriteTime = File.GetLastWriteTime(path + ".png");
		bool flag = date.Year != 1 && date == lastWriteTime;
		if (!flag)
		{
			Load(flag, ref tex, ref sprites, "");
			if (File.Exists(path + "_snow.png"))
			{
				Load(flag, ref texSnow, ref spritesSnow, "_snow");
			}
			date = lastWriteTime;
		}
	}

	public void Load(bool dateMatched, ref Texture2D tex, ref Sprite[] sprites, string suffix)
	{
		if (dateMatched && (bool)tex)
		{
			return;
		}
		if ((bool)tex)
		{
			Texture2D texture2D = IO.LoadPNG(path + suffix + ".png");
			if (texture2D.width != tex.width || texture2D.height != tex.height)
			{
				Debug.Log(texture2D.width + "/" + texture2D.height + "/" + path);
				tex.Reinitialize(texture2D.width, texture2D.height);
			}
			tex.SetPixels32(texture2D.GetPixels32());
			tex.Apply();
			UnityEngine.Object.Destroy(texture2D);
		}
		else
		{
			tex = IO.LoadPNG(path + suffix + ".png");
			int num = tex.width / frame;
			int height = tex.height;
			sprites = new Sprite[frame];
			for (int i = 0; i < frame; i++)
			{
				sprites[i] = Sprite.Create(tex, new Rect(i * num, 0f, num, height), new Vector2(0.5f, 0.5f), 100f, 0u, SpriteMeshType.FullRect);
			}
		}
	}
}
```

:::
## -SpriteReplacer

::: details File Removed
```cs
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class SpriteReplacer
{
	public static Dictionary<string, SpriteReplacer> dictSkins = new Dictionary<string, SpriteReplacer>();

	public static Dictionary<string, string> dictModItems = new Dictionary<string, string>();

	public bool hasChacked;

	public SpriteData data;

	public static Dictionary<string, SpriteReplacer> ListSkins()
	{
		List<string> list = new List<string>();
		foreach (KeyValuePair<string, SpriteReplacer> dictSkin in dictSkins)
		{
			if (!File.Exists(dictSkin.Value.data.path + ".png"))
			{
				list.Add(dictSkin.Key);
			}
		}
		foreach (string item in list)
		{
			dictSkins.Remove(item);
		}
		FileInfo[] files = new DirectoryInfo(CorePath.custom + "Skin").GetFiles();
		foreach (FileInfo fileInfo in files)
		{
			if (fileInfo.Extension == ".png")
			{
				string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileInfo.FullName);
				if (!dictSkins.ContainsKey(fileNameWithoutExtension))
				{
					SpriteReplacer spriteReplacer = new SpriteReplacer();
					spriteReplacer.data = new SpriteData
					{
						path = fileInfo.GetFullFileNameWithoutExtension()
					};
					spriteReplacer.data.Init();
					dictSkins.Add(fileNameWithoutExtension, spriteReplacer);
				}
			}
		}
		return dictSkins;
	}

	public bool HasSprite(string id)
	{
		if (!hasChacked)
		{
			try
			{
				if (dictModItems.ContainsKey(id))
				{
					Debug.Log(id + ":" + dictModItems[id]);
					data = new SpriteData
					{
						path = dictModItems[id]
					};
					data.Init();
				}
				else
				{
					string text = CorePath.packageCore + "Texture/Item/" + id;
					if (File.Exists(text + ".png"))
					{
						data = new SpriteData
						{
							path = text
						};
						data.Init();
					}
				}
				hasChacked = true;
			}
			catch (Exception ex)
			{
				Debug.Log("Error during fetching spirte:" + ex);
			}
		}
		return data != null;
	}
}
```

:::
## -SpriteReplacerAnimation

::: details File Removed
```cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class SpriteReplacerAnimation : MonoBehaviour
{
	public enum Type
	{
		Default,
		Boat
	}

	public static Dictionary<string, SpriteData> dict = new Dictionary<string, SpriteData>();

	public Type type;

	public string id;

	public SpriteData data;

	[NonSerialized]
	public SpriteRenderer sr;

	private int index;

	private void Awake()
	{
		if (!id.IsEmpty())
		{
			SetData(id);
		}
	}

	public void SetData(string id)
	{
		this.id = id;
		string text = id.IsEmpty(base.name + "_anime");
		string path = CorePath.packageCore + "Texture/Item/" + text;
		data = dict.TryGetValue(text);
		if (data == null)
		{
			data = new SpriteData
			{
				path = path
			};
			data.Init();
			dict.Add(text, data);
		}
		sr = GetComponent<SpriteRenderer>();
		sr.sprite = data.GetSprite();
		if (type == Type.Default)
		{
			CancelInvoke();
			InvokeRepeating("Refresh", 0f, data.time);
		}
	}

	private void Refresh()
	{
		index++;
		if (index >= data.frame)
		{
			index = 0;
		}
		sr.sprite = data.GetSprites()[index];
	}
}
```

:::